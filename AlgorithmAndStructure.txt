————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————
  动态规划
  思想：通常用于求解具有某种最优性质的问题，将原问题分解为若干子问题，再求解子问题以得到原问题的解。
————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————
  示例题目：设每次为1或2, 问到n有多少种组合？
  例如：n=3, 即有三种：1+1+1, 1+2, 2+1
----------------------------------------------------------------------------
func climbStairs(n int) int {
	p, q, r := 0, 0, 1
	for i := 1; i <= n; i++ {
		p = q
		q = r
		r = p + q
	}
	return r
}
————————————————————————————————————————————————————————————————————————————
  示例题目：设有一个N × M的表格及初始正整数，表格里单元格内都有数字（包括开始和结束），从表格左上角走到右下角（只能向右或向下），当前记录的数字与单元格数字相加，若小于等于0则停止走动，，大于0则记录该数字并继续走动，问初始正整数至少为多少时才能走到右下角且最后数字为正整数？
  例如：表格为{［-2, -3, 3］，［-5, ，-10, 1］，［10, 30， -5］}，则初始正整数至少为7
----------------------------------------------------------------------------
int TableMove(int** dungeon) {
	int row = dungeon.length;
	int col = dungeon[0].length;
	//该数组表示移动到i,j位置单元格时所需最小的整数
	int[][] dp = new int[row][col];
	for(int i = row-1; i >= 0; i--) {
		for(int j = col-1; j >= 0; j--){
			if(i == row-1 && j == col-1) {
				dp[i][j] = Math.max(1, 1-dungeon[i][j]);
			} else if(i == row-1) {
				dp[i][j] = Math.max(1, dp[i][j+1]-dungeon[i][j]);
			} else if(j == col-1) {
				dp[i][j] = Math.max(1, dp[i+1][j]-dungeon[i][j]);
			} else {
				dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j]);
			}
		}
	}
	return dp[0][0];
}
————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————
