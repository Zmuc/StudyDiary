————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————
  动态规划
  思想：通常用于求解具有某种最优性质的问题，将原问题分解为若干子问题，再求解子问题以得到原问题的解。
————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————
  示例题目：设每次为1或2, 问到n有多少种组合？
  例如：n=3, 即有三种：1+1+1, 1+2, 2+1
----------------------------------------------------------------------------
func climbStairs(n int) int {
	p, q, r := 0, 0, 1
	for i := 1; i <= n; i++ {
		p = q
		q = r
		r = p + q
	}
	return r
}
————————————————————————————————————————————————————————————————————————————
  示例题目：设有一个N × M的表格及初始正整数，表格里单元格内都有数字（包括开始和结束），从表格左上角走到右下角（只能向右或向下），当前记录的数字与单元格数字相加，若小于等于0则停止走动，，大于0则记录该数字并继续走动，问初始正整数至少为多少时才能走到右下角且最后数字为正整数？
  例如：表格为{［-2, -3, 3］，［-5, ，-10, 1］，［10, 30， -5］}，则初始正整数至少为7
----------------------------------------------------------------------------
int TableMove(int** dungeon) {
	int row = dungeon.length;
	int col = dungeon[0].length;
	//该数组表示移动到i,j位置单元格时所需最小的整数
	int[][] dp = new int[row][col];
	for(int i = row-1; i >= 0; i--) {
		for(int j = col-1; j >= 0; j--){
			if(i == row-1 && j == col-1) {
				dp[i][j] = Math.max(1, 1-dungeon[i][j]);
			} else if(i == row-1) {
				dp[i][j] = Math.max(1, dp[i][j+1]-dungeon[i][j]);
			} else if(j == col-1) {
				dp[i][j] = Math.max(1, dp[i+1][j]-dungeon[i][j]);
			} else {
				dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j]);
			}
		}
	}
	return dp[0][0];
}
————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————

————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————
  状态压缩
  思想：通常用在状态非常多但构成比较简单的情况，将该情况压缩为N进制状态
————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————
  示例题目：设一个N × N的表格里有K个点，每个点九宫格的范围内没有其他点，共有多少种摆法？
  例如：2 × 2有2个点，0； 3 × 3有3个点， 8; 5 × 5有8个点， 27
----------------------------------------------------------------------------
long long dp[10][15000][80];
long long state[1000005];
long long spot[1000005];

int NoInterfere(int n, int k)
{
	long long ans = 0;
	long long sum = 0;

	// 状态压缩
	int tot = (1<<n) - 1;
	for(int i = 0; i <= tot; i++)
	{
		if(!((i<<1) & i)) {
			state[++ans] = i;
			int t = i;
			while(t)
			{
				spot[ans] += t%2;
				t >>= 1;
			}
		}
	}

	// 根据压缩后的状态计算
	for(int i = 1; i <= ans; i++)
	{
		if(spot[i] <= k) {
			dp[1][i][spot[i]] = 1;
		}
	}

	for(int i = 2; i <= n; i++)
	{
		for(int j = 1; j <= ans; j++)
		{
			for(int p = 1; p <= ans; p++)
			{
				if(state[j] & state[p]) {
					continue;
				}

				if(state[j] & (state[p]<<1)) {
					continue;
				}

				if((state[j]<<1) & state[p]) {
					continue;
				}

				for(int s = 1; s <= k; s++)
				{
					if(spot[j]+s > k) {
						continue;
					}
					dp[i][j][spot[j]+s] += dp[i-1][p][s];
				}
			}
		}
	}

	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= ans; j++)
		{
			sum += dp[i][j][k];
		}
	}

	return sum;
}
————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————

