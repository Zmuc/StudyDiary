C/C++基础：
------------------------------------------------------------------------------------------------------------------------
1. const关键字作用
1）防止被修饰变量的内容改变，需要先初始化（类成员变量只能在初始化列表中赋值）
2）const可以修饰指针：
    - 常量指针/常指针（const int* ptr），指针的值为常量，不能修改其指向地址（*ptr），但可以修改指向对象和指向对象的值
    - 指针常量，（int* const ptr），指针为常量，不能修改指向对象(ptr)，但可以修改指向地址和指向对象的值
    - 指向常量的常指针（const int* const ptr），同上，只能修改指向对象的值
3）const可以修饰函数：
    - 修饰形参表的输入参数，在函数内部不能修改其值
    - 修饰函数返回值，和修饰变量等同
    - 修饰类的成员函数，指定其为常函数，不能修改成员变量，不能调用非const成员函数
    - 修饰类的成员函数，指定其返回值为const，使其不为左值
    - 修饰类的成员函数，const不能与static同时使用，因为静态成员函数不含有this指针（不能实例化），但const成员函数必须实例化（this指向内容不可变）
4）const可以修饰类对象，对象的任何成员都不能被修改，只能调用const成员函数
5）const可以替代#define宏定义：
    - 宏定义编译时，不能进行调试，生命周期结束于编译时；const运行时
    - 宏定义不会分配内存，存储在代码段；const会分配内存
    - 宏定义无数据类型区别；const有数据类型区别，会进行类型安全检查
    - 宏定义函数内定义全局生效；const函数内定义本函数内生效

2. class与struct区别
1）class成员默认为private属性的；struct成员默认为public属性的
2）class继承默认是private继承；struct继承默认是public继承
3）class可以使用模板，而struct不能
4）C++中struct类似于class，可以包含成员函数；C中struct不能包含函数

3. 函数重载，函数覆盖，函数隐藏的区别
1）函数重载：类中一组具有相同函数名，但参数列表不同的函数，根据函数调用时传入的实参类型，匹配对应的函数并调用
2）函数覆盖/函数重写：类父子中具有相同的函数原型（函数名、参数列表），父类定义为虚函数，子类重新实现该函数
3）函数隐藏：类父子中具有相同的函数原型（函数名、参数列表），父类定义为非虚函数，则在子类中隐藏父类的同名函数

4. 虚函数
1）虚函数的实现：
    - 虚函数指针，指向对应的虚函数，总是被存放在该对象的地址首位（提高性能），对外部不可见
    - 虚函数表，虚函数指针按照一定顺序构成的表状结构，一个类公用一张虚函数表
2）虚函数是实现多态的机制
3）纯虚函数：基类虚函数原型后加［ = 0 ］，提供该函数的规范接口：
    - 纯虚函数在基类没有定义
    - 纯虚函数必须在派生类中实现
    - 含有纯虚拟函数的类称为抽象类，不能定义对象
4）构造函数和析构函数是否可以是虚函数：
    - 构造函数不能是虚函数，因为虚函数是基于对象，而构造函数用于定义对象
    - 析构函数可以是虚函数，因为当基类指针指向派生类对象时，若基类析构函数不是虚函数，则只析构了基类，造成派生类对象没有释放的问题（内存泄漏）
5）动态分配堆上内存时，析构函数必须是虚函数，以防止内存泄漏
6）部分函数不可以是虚函数：
    - 构造函数：无法继承且构造时未实例化，无法通过虚函数表指针寻找虚函数
    - 内联成员函数：内联函数在编译时展开，而虚函数则是运行时多态
    - 静态成员函数：静态函数被类成员共享，无法继承
    - 友元函数：不属于成员函数、无法继承
    - 普通函数：编译时已绑定，无法继承

5. 多态
1）派生类指针可以赋给基类指针，通过基类指针调用基类和派生类中的同名虚函数时：
    - 指向基类则调用基类虚函数
    - 指向派生类则调用派生类虚函数
2）派生类对象可以赋给基类引用，通过基类引用调用基类和派生类中的同名虚函数时：
    - 引用的是基类对象则调用基类虚函数
    - 引用的是派生类对象则调用派生类虚函数
3）多态是运行时概念，所以在构造函数和析构函数中调用虚函数不是多态（编译时即可确定）

6. 指针
1）普通指针（指向一个对象的地址）：
    - int* p = &num，p指向变量num
    - int* p_arr0 = arr，p_arr0指向arr数组第一个元素arr[0]
    - 不需要&取地址：数组（数组第一个元素的地址），函数（函数名的地址），字符串字面值常量右值（字符串在内存中的地址）
2）指向紧邻对象所占空间的下一个位置，常与迭代器使用的指针
3）智能指针（管理在堆上分配的内存）：
    - 将普通的指针封装为一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏
    - auto_ptr：C++11已弃用（以下C++11支持），存在潜在的内存崩溃问题（p2 = p1时，p2剥夺了p1的所有权，导致程序访问p1报错）
    - unique_ptr：独占式，同一时间内只有一个智能指针可以指向某对象（p2 = p1时报错；p2 = unique_ptr临时右值时成功，临时对象所有权让给p2后被销毁）
    - shared_ptr：共享式，多个智能指针可以指向同一对象，用计数机制来表明资源被几个指针共享，该对象和资源会在最后一个引用被销毁时释放
        - 存在内存泄漏：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效
        - use_count：返回引用计数的个数
        - unique：返回所有权是否为独占（use_count为1）
        - swap：交换两个shared_ptr对象（交换所拥有对象）
        - reset：放弃内部对象所有权或变更拥有对象, 会导致原有对象的引用计数减少
        - release：当前指针会释放资源所有权，计数减一
    - weak_ptr：搭配shared_ptr使用（无实际用处），不影响所指堆内存空间的引用计数，为解决shared_ptr相互引用时的死锁问题
4）空指针：指针变量赋值为NULL（C为 ((void*)0) ；C++为0）或nullptr
5）void*指针：无类型，不能对void*类型的指针做解指针操作，必须要进行正确的类型转换
6）常量指针：const int* ptr，指针的值为常量（即指向地址（*ptr）为常量），可以修改指向对象和指向对象的值
7）悬空指针：指向一块被已经被释放的内存
8）野指针：不确定其具体指向，最常来自于未初始化

网络：
------------------------------------------------------------------------------------------------------------------------
1. OSI模型
由高到低：
1）应用层：为特定类型的网络应用提供访问OSI环境的手段，如HTTP，DHCP等
    - TCP协议服务及端口号：
        - HTTP（超文本传输协议）：80，传输Internet浏览器普通文本、超文本、音视频等数据
        - HTTPS（安全文本传输协议）：443，基于HTTP，应用了安全套接字层（SSL），可对数据进行加密和压缩
        - FTP（文件传输协议）：21（控制数据传输）/20（数据传输），用于文件传输，能进行目录操作和文件权限操作
        - SSH（安全外壳协议）：22
        - Telnet（远程登录）：23
        - SMTP（简单邮件传输协议）：25，负责服务器之间的邮件传送
        - POP3（邮局协议版本3）：110，用于支持客户端远程管理在服务器上的电子邮件
        - IMAP（交互式邮件存取协议）：143，类似POP3，但客户端收取的邮件会保留在服务器上，同时客户端上的操作会反馈到服务器上
    - UDP协议服务及端口号：
        - DNS（域名服务器）：53，用于域名解析
        - TFTP（简单文件传输协议）：69，类似TCP上的FTP，仅进行文件上传和下载
2）表示层：对数据进行翻译、加密、压缩等操作
3）会话层：确定会话的连接和中断
4）传输层：负责向两个主机中进程之间的通信提供端到端接口
    - 传输控制协议（TCP）：面向连接，面向字节流，可靠，全双工
        - TCP报文（封装在网络层的IP数据报中）：
            - 报头：源端口（16位），目的端口（16）；
                   序列号（32，SYN标识位1时为初始序列号）；
                   确认序列号（32，如果ACK标识位1则为准备接收的报文序列号）；
                   数据偏移（4，数据从何处开始），保留（6），标识位（6：URG、ACK、PSH、RST、SYN、FIN），窗口大小（16）；
                   校验和（16），紧急指针（16，URG标识位1时生效）；
                   选项（1 - ？，长度不定，没有选项即1字节的域等于0）
            - 数据：TCP报文负载的数据
        - 三次握手：
            - A -> B：客户端A向服务器B发出建立连接请求，SYN=j（j为序列号，SYN标识位为1）
            - A <- B：服务器B收到并确认客户端A，SYN=k，ACK=j+1（ACK为确认，确认号为收到的序列号+1）
            - A -> B：客户端A收到并确认服务端B，ACK=k+1
        - 四次挥手：
            - A -> B：客户端A数据发送完，向服务器B发出释放连接请求，FIN=m（m为序列号，FIN标识位为1）
            - A <- B：服务器B收到并确认客户端A，等待数据传输完成，ACK=m+1（ACK为确认，确认号为收到的序列号+1）
            - A <- B：数据传输完成，向客户端A发出释放连接请求，FIN=n，ACK=m+1
            - A -> B：客户端A收到并确认服务端B，ACK=n+1
    - 用户数据报协议（UDP）：无连接，面向报文，不可靠
        - UDP报文（封装在网络层的IP数据报中）：
            - 报头：源端口（16位），目的端口（16）；
                   长度（16，UDP报文长度，最小为8，只有报头），校验和（16）
            - 数据：UDP报文负载的数据
5）网络层：处理不同网络之间的数据路由和发送，包括路由选择、分段组合、流量/拥塞控制等
    - 网际协议地址（IP地址，IPv4/IPv6）：为互联网每个网络/主机分配一个逻辑地址（网络拓扑分配）
        - IP数据报（封装在数据链路层的帧的数据中）：
            - 报头：IP协议版本（4位），报头长度（4），服务类型（8：优先权3 短延时位1 高吞吐位1 高可靠位1 保留2），总长度（16）；
                   标识（16，MTU导致分片后正确重组），标志（3，无效-能否分片-后面还有分片），片偏移（13，片在分组相对位置）；
                   生存时间（8，限制路由跳数），上层协议标识（8，TCP/UDP等），校验和（16，通过报头校验有效性）；
                   源IP地址（32）；
                   目的IP地址（32）；
                   选项（1 - 40，支持排错、测量以及安全等，IPv6固定）
            - 数据：不同MTU（最大传输单元）存在分片问题，将数据分成连续片
        - IPv4分类（IPv4 32位， 分网络地址 + 主机地址）：
            - A类：1-127.x.x.x（0x），单播地址，网络地址8，主机地址24
            - B类：128-191.x.x.x（10x），单播地址，网络地址16，主机地址16
            - C类：192-223.x.x.x（110x），单播地址，网络地址24，主机地址8
            - D类：224-239.x.x.x（1110x），多播地址
            - E类：240-255.x.x.x（11110x），保留
            - 特殊地址：全0/全1，127.0.0.1（代表本地IP地址）-127.255.255.255用于回路测试
            - 默认子网掩码：网络地址为1，主机地址为0
            - 子网划分（从主机地址划子网）：把每类IP网络划分成子网，如255.255.255.192/26代表子网掩码有26个1，其子网数有(主机地址位-(32-26))^2
            - 超网划分（从网络地址划超网）：把若干小网络组合成超网
            - 公网连Internet，私网连局域网
    - 地址解析协议（ARP）：实现IP地址到MAC地址的转换
        - 发送ARP包，通过FF:FF:FF:FF:FF:FF + IP广播，获取目的MAC地址
        - ARP攻击：主要存在局域网中，通过发送ARP欺骗包（伪造IP及MAC地址），进行嗅探（截取数据再转发），网关欺骗（无法上网），IP地址冲突
    - Internet控制报文协议（ICMP）：用于在IP主机、路由器之间传递控制消息
        - ICMP报文包含在IP数据报的数据中
        - 消息类型：
            - 响应请求：发送响应请求报文（type=8），没有异常则返回应答请求报文（type=0），如ping
            - 目标不可到达，源抑制和超时报文：发送不可达报文（type=3， code=？），告知具体的不可达信息（code决定）
            - 时间戳：发送时间戳请求报文（type=13），收到返回的时间戳应答报文（type=14），计算来回一次的传输时间
        - ICMP攻击：通过发送ICMP报文，进行ICMP超限尺寸攻击（部分操作系统设限导致内存分配错误），ICMP报文轰炸（长时间，大量，连续）
    - Internet组管理协议（IGMP）：用于在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系
        - 组播：IP主机发给组播路由器（1份），组播路由器发给需要的组播组成员（多份）
        - IGMPv1：管理组播组成员基于查询（由组播路由协议如PIM决定IGMP查询器）和响应（超时响应来确定组播组成员离开）机制
        - IGMPv2：增加了查询器选举机制（IP地址最小成为查询器）和离开组（通知）机制
        - IGMPv3：增强了主机控制，查询和报告报文
    - 路由选择协议：
        - RIP协议：基于距离矢量的动态路由选择协议
        - OSPF协议：开放式最短路径优先
6）数据链路层：对电信号进行分组，即以太网协议Ethernet（标准），用于处理同一网络中不同设备之间的通信
    - 帧：一组电信号，分成报头head和数据data
        - 报头（固定18字节）：发送者/源MAC地址（6字节），接收者/目的MAC地址（6字节），数据类型（6字节）
        - 数据（46 - 1500字节）：数据包具体内容，超过最大限制分片
    - MAC地址（12位16进制）：Ethernet规定接入网络的设备都必要网卡，源/目的地址便是网卡的地址，即MAC地址（制造商分配）
    - 数据链路层工作方式：局域网广播
7）物理层：物理/硬件，中间物理链接如光缆、电缆、双绞线、无线电波；中间电信号，即010101...二进制
8）应用层，表示层，会话层 -> 应用层；数据链路层，物理层 -> 网络接口层

2. sshd_config部分详解
1）MaxSessions：控制单个TCP连接上支持的多路复用会话的数量
    - MaxSessions=0：禁止登录/shell/子系统会话
    - MaxSessions=1：禁用多路复用
    - MaxSessions=2+：允许多路复用


安全：
------------------------------------------------------------------------------------------------------------------------



其他：
------------------------------------------------------------------------------------------------------------------------
1. 内存布局
1）低地址 -> 高地址：代码区 -> 数据区 -> 堆区 -> 栈区
2）分区/段：
    - 代码区：.text，也称文本段，存放着编译后形成的CPU指令
    - 数据区：存放三类数据
        - 只读数据段：const及文字等常量
        - 已初始化的读写数据段：.data，已初始化的全局/静态变量
        - 未初始化的读写数据段：.bss，未初始化的全局/静态变量，程序执行前BSS段会自动清0
    - 堆区：大小可变，不连续（会使内存空间不连续，造成浪费），运行时由程序员动态分配，存放malloc, new等，通过链表分配
    - 栈区：大小可变（空间有限），连续，运行时由系统自动分配，存放函数参数，局部变量等，通过先进后出分配
3）任何程序数据都不会存储在地址为0的内存块中，被操作系统预留的内存块

2. 进程与线程
1）定义：
    - 进程：操作系统进行资源分配和调度的基本单位，是具有一定独立功能的程序在一个数据集上的一次动态执行过程
    - 线程：程序执行流的最小单元，是处理器调度和分派的基本单位，执行单一的顺序控制流程
2）一个进程由一个或多个线程组成，线程是进程中代码的不同执行线路
3）进程之间相互独立，线程共享某个进程的资源，对其他进程不可见

3. 进程间通信
1）管道（pipe），有名管道（named pipe）：管道用于父子进程间的通信，有名管道允许非父子进程间的通信
2）信号（signal）：信号是一种软件中断，向进程传递有关其他进程，操作系统和硬件状态的信息的方法，可以改变程序的流程
3）信号量（semaphore）：进程之间或同一进程的不同线程之间的同步互斥手段：
    - PV操作：P-1，<0则挂起执行线程；V+1，<=0则唤醒一个挂起的线程
    - PV操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区
    - PV操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环
    - 互斥信号量初值一般为1
4）消息队列（message queue）：消息队列是消息的链接表，具有写权限的进程按照一定规则向消息队列中添加新信息；具有读权限的进程则可以从消息队列中读取信息
5）共享内存（shared memory）：多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新（需要依靠同步操作，如互斥锁和信号量等）
6）套接字（socket）：用于网络中不同机器之间的进程间通信

4. 数据类型
1）字节数（32/64）：
    - char：1
    - short：2
    - int：4
    - long：4/8
    - long long：8
    - float：4
    - double：8
    - char *（指针变量）：4/8
2）类型强制转换：
    - 隐式强制转换：TYPE b = a；
    - 显式强制转换（包括以下C++函数）：TYPE b = (TYPE) a；
    - static_cast：用于基本类型的强制转换
    - const_cast：用于转换去除const属性
    - reinterpret_cast：用于不同类型之间的指针之间的转换，如不同类型之间函数指针的转换
    - dynamic_cast：用于多态类型之间的类型转换

5. 左值与右值
左值：lvalue（locator value），代表在内存中占有确定位置的对象（即有地址）
右值：rvalue，不在内存中占有确定位置的表达式

6. 深拷贝与浅拷贝
浅拷贝：通过拷贝他们所共享数据的指针来工作
深拷贝：通过拷贝数据来工作，互不影响

7. 计算机二进制
1）1字符 = 2字节
2）1字节 = 8位 = 8bit（比特）
3）汉字/中文标点符号 = 1字符；字母/数字/英文标点符号 = 1字节

