C/C++基础：
------------------------------------------------------------------------------------------------------------------------
1. const关键字作用
1）防止被修饰变量的内容改变，需要先初始化（类成员变量只能在初始化列表中赋值）
2）const可以修饰指针：
    - 常量指针/常指针（const int* ptr），指针的值为常量，不能修改其指向地址（*ptr），但可以修改指向对象和指向对象的值
    - 指针常量，（int* const ptr），指针为常量，不能修改指向对象(ptr)，但可以修改指向地址和指向对象的值
    - 指向常量的常指针（const int* const ptr），同上，只能修改指向对象的值
3）const可以修饰函数：
    - 修饰形参表的输入参数，在函数内部不能修改其值
    - 修饰函数返回值，和修饰变量等同
    - 修饰类的成员函数，指定其为常函数，不能修改成员变量，不能调用非const成员函数
    - 修饰类的成员函数，指定其返回值为const，使其不为左值
    - 修饰类的成员函数，const不能与static同时使用，因为静态成员函数不含有this指针（不能实例化），但const成员函数必须实例化（this指向内容不可变）
4）const可以修饰类对象，对象的任何成员都不能被修改，只能调用const成员函数
5）const可以替代#define宏定义：
    - 宏定义编译时，不能进行调试，生命周期结束于编译时；const运行时
    - 宏定义不会分配内存，存储在代码段；const会分配内存
    - 宏定义无数据类型区别；const有数据类型区别，会进行类型安全检查
    - 宏定义函数内定义全局生效；const函数内定义本函数内生效

2. class与struct区别
1）class成员默认为private属性的；struct成员默认为public属性的
2）class继承默认是private继承；struct继承默认是public继承
3）class可以使用模板，而struct不能
4）C++中struct类似于class，可以包含成员函数；C中struct不能包含函数

3. 函数重载，函数覆盖，函数隐藏的区别
1）函数重载：类中一组具有相同函数名，但参数列表不同的函数，根据函数调用时传入的实参类型，匹配对应的函数并调用
2）函数覆盖/函数重写：类父子中具有相同的函数原型（函数名、参数列表），父类定义为虚函数，子类重新实现该函数
3）函数隐藏：类父子中具有相同的函数原型（函数名、参数列表），父类定义为非虚函数，则在子类中隐藏父类的同名函数

4. 虚函数
1）虚函数的实现：
    - 虚函数指针，指向对应的虚函数，总是被存放在该对象的地址首位（提高性能），对外部不可见
    - 虚函数表，虚函数指针按照一定顺序构成的表状结构，一个类公用一张虚函数表
2）虚函数是实现多态的机制
3）纯虚函数：基类虚函数原型后加［ = 0 ］，提供该函数的规范接口：
    - 纯虚函数在基类没有定义
    - 纯虚函数必须在派生类中实现
    - 含有纯虚拟函数的类称为抽象类，不能定义对象
4）构造函数和析构函数是否可以是虚函数：
    - 构造函数不能是虚函数，因为虚函数是基于对象，而构造函数用于定义对象
    - 析构函数可以是虚函数，因为当基类指针指向派生类对象时，若基类析构函数不是虚函数，则只析构了基类，造成派生类对象没有释放的问题（内存泄漏）
5）动态分配堆上内存时，析构函数必须是虚函数，以防止内存泄漏
6）部分函数不可以是虚函数：
    - 构造函数：无法继承且构造时未实例化，无法通过虚函数表指针寻找虚函数
    - 内联成员函数：内联函数在编译时展开，而虚函数则是运行时多态
    - 静态成员函数：静态函数被类成员共享，无法继承
    - 友元函数：不属于成员函数、无法继承
    - 普通函数：编译时已绑定，无法继承

5. 多态
1）派生类指针可以赋给基类指针，通过基类指针调用基类和派生类中的同名虚函数时：
    - 指向基类则调用基类虚函数
    - 指向派生类则调用派生类虚函数
2）派生类对象可以赋给基类引用，通过基类引用调用基类和派生类中的同名虚函数时：
    - 引用的是基类对象则调用基类虚函数
    - 引用的是派生类对象则调用派生类虚函数
3）多态是运行时概念，所以在构造函数和析构函数中调用虚函数不是多态（编译时即可确定）

6. 指针
1）普通指针（指向一个对象的地址）：
    - int* p = &num，p指向变量num
    - int* p_arr0 = arr，p_arr0指向arr数组第一个元素arr[0]
    - 不需要&取地址：数组（数组第一个元素的地址），函数（函数名的地址），字符串字面值常量右值（字符串在内存中的地址）
2）指向紧邻对象所占空间的下一个位置，常与迭代器使用的指针
3）智能指针（管理在堆上分配的内存）：
    - 将普通的指针封装为一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏
    - auto_ptr：C++11已弃用（以下C++11支持），存在潜在的内存崩溃问题（p2 = p1时，p2剥夺了p1的所有权，导致程序访问p1报错）
    - unique_ptr：独占式，同一时间内只有一个智能指针可以指向某对象（p2 = p1时报错；p2 = unique_ptr临时右值时成功，临时对象所有权让给p2后被销毁）
    - shared_ptr：共享式，多个智能指针可以指向同一对象，用计数机制来表明资源被几个指针共享，该对象和资源会在最后一个引用被销毁时释放
        - 存在内存泄漏：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效
        - use_count：返回引用计数的个数
        - unique：返回所有权是否为独占（use_count为1）
        - swap：交换两个shared_ptr对象（交换所拥有对象）
        - reset：放弃内部对象所有权或变更拥有对象, 会导致原有对象的引用计数减少
        - release：当前指针会释放资源所有权，计数减一
    - weak_ptr：搭配shared_ptr使用（无实际用处），不影响所指堆内存空间的引用计数，为解决shared_ptr相互引用时的死锁问题
4）空指针：指针变量赋值为NULL（C为 ((void*)0) ；C++为0）或nullptr
5）void*指针：无类型，不能对void*类型的指针做解指针操作，必须要进行正确的类型转换
6）常量指针：const int* ptr，指针的值为常量（即指向地址（*ptr）为常量），可以修改指向对象和指向对象的值
7）悬空指针：指向一块被已经被释放的内存
8）野指针：不确定其具体指向，最常来自于未初始化

网络编程：
------------------------------------------------------------------------------------------------------------------------
1. sshd_config部分详解
1）MaxSessions：控制单个TCP连接上支持的多路复用会话的数量
    - MaxSessions=0：禁止登录/shell/子系统会话
    - MaxSessions=1：禁用多路复用
    - MaxSessions=2+：允许多路复用


安全：
------------------------------------------------------------------------------------------------------------------------



其他：
------------------------------------------------------------------------------------------------------------------------
1. 内存布局
1）低地址 -> 高地址：代码区 -> 数据区 -> 堆区 -> 栈区
2）分区/段：
    - 代码区：.text，也称文本段，存放着编译后形成的CPU指令
    - 数据区：存放三类数据
        - 只读数据段：const及文字等常量
        - 已初始化的读写数据段：.data，已初始化的全局/静态变量
        - 未初始化的读写数据段：.bss，未初始化的全局/静态变量，程序执行前BSS段会自动清0
    - 堆区：大小可变，不连续（会使内存空间不连续，造成浪费），运行时由程序员动态分配，存放malloc, new等，通过链表分配
    - 栈区：大小可变（空间有限），连续，运行时由系统自动分配，存放函数参数，局部变量等，通过先进后出分配
3）任何程序数据都不会存储在地址为0的内存块中，被操作系统预留的内存块

2. 进程与线程
1）定义：
    - 进程：操作系统进行资源分配和调度的基本单位，是具有一定独立功能的程序在一个数据集上的一次动态执行过程
    - 线程：程序执行流的最小单元，是处理器调度和分派的基本单位，执行单一的顺序控制流程
2）一个进程由一个或多个线程组成，线程是进程中代码的不同执行线路
3）进程之间相互独立，线程共享某个进程的资源，对其他进程不可见

3. 进程间通信
1）管道（pipe），有名管道（named pipe）：管道用于父子进程间的通信，有名管道允许非父子进程间的通信
2）信号（signal）：信号是一种软件中断，向进程传递有关其他进程，操作系统和硬件状态的信息的方法，可以改变程序的流程
3）信号量（semaphore）：进程之间或同一进程的不同线程之间的同步互斥手段：
    - PV操作：P-1，<0则挂起执行线程；V+1，<=0则唤醒一个挂起的线程
    - PV操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区
    - PV操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环
    - 互斥信号量初值一般为1
4）消息队列（message queue）：消息队列是消息的链接表，具有写权限的进程按照一定规则向消息队列中添加新信息；具有读权限的进程则可以从消息队列中读取信息
5）共享内存（shared memory）：多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新（需要依靠同步操作，如互斥锁和信号量等）
6）套接字（socket）：用于网络中不同机器之间的进程间通信

4. 数据类型
1）字节数（32/64）：
    - char：1
    - short：2
    - int：4
    - long：4/8
    - long long：8
    - float：4
    - double：8
    - char *（指针变量）：4/8
2）类型强制转换：
    - 隐式强制转换：TYPE b = a；
    - 显式强制转换（包括以下C++函数）：TYPE b = (TYPE) a；
    - static_cast：用于基本类型的强制转换
    - const_cast：用于转换去除const属性
    - reinterpret_cast：用于不同类型之间的指针之间的转换，如不同类型之间函数指针的转换
    - dynamic_cast：用于多态类型之间的类型转换

5. 左值与右值
左值：lvalue（locator value），代表在内存中占有确定位置的对象（即有地址）
右值：rvalue，不在内存中占有确定位置的表达式

6. 深拷贝与浅拷贝
浅拷贝：通过拷贝他们所共享数据的指针来工作
深拷贝：通过拷贝数据来工作，互不影响

