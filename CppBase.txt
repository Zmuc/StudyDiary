C/C++基础：
------------------------------------------------------------------------------------------------------------------------
1. const关键字作用
1）防止被修饰变量的内容改变，需要先初始化（类成员变量只能在初始化列表中赋值）
2）const可以修饰指针：
    - 常量指针/常指针（const int* ptr），指针的值为常量，不能修改其指向地址（*ptr），但可以修改指向对象和指向对象的值
    - 指针常量，（int* const ptr），指针为常量，不能修改指向对象(ptr)，但可以修改指向地址和指向对象的值
    - 指向常量的常指针（const int* const ptr），同上，只能修改指向对象的值
3）const可以修饰函数：
    - 修饰形参表的输入参数，在函数内部不能修改其值
    - 修饰函数返回值，和修饰变量等同
    - 修饰类的成员函数，指定其为常函数，不能修改成员变量，不能调用非const成员函数
    - 修饰类的成员函数，指定其返回值为const，使其不为左值
    - 修饰类的成员函数，const不能与static同时使用，因为静态成员函数不含有this指针（不能实例化），但const成员函数必须实例化（this指向内容不可变）
4）const可以修饰类对象，对象的任何成员都不能被修改，只能调用const成员函数
5）const可以替代#define宏定义：
    - 宏定义编译时，不能进行调试，生命周期结束于编译时；const运行时
    - 宏定义不会分配内存，存储在代码段；const会分配内存
    - 宏定义无数据类型区别；const有数据类型区别，会进行类型安全检查
    - 宏定义函数内定义全局生效；const函数内定义本函数内生效

2. class与struct区别
1）class成员默认为private属性的；struct成员默认为public属性的
2）class继承默认是private继承；struct继承默认是public继承
3）class可以使用模板，而struct不能
4）C++中struct类似于class，可以包含成员函数；C中struct不能包含函数

3. 函数重载，函数覆盖，函数隐藏的区别
1）函数重载：类中一组具有相同函数名，但参数列表不同的函数，根据函数调用时传入的实参类型，匹配对应的函数并调用
2）函数覆盖/函数重写：类父子中具有相同的函数原型（函数名、参数列表），父类定义为虚函数，子类重新实现该函数
3）函数隐藏：类父子中具有相同的函数原型（函数名、参数列表），父类定义为非虚函数，则在子类中隐藏父类的同名函数

4. 虚函数
1）虚函数的实现：
    - 虚函数指针，指向对应的虚函数，总是被存放在该对象的地址首位（提高性能），对外部不可见
    - 虚函数表，虚函数指针按照一定顺序构成的表状结构，一个类公用一张虚函数表
2）虚函数是实现多态的机制
3）纯虚函数：基类虚函数原型后加［ = 0 ］，提供该函数的规范接口：
    - 纯虚函数在基类没有定义
    - 纯虚函数必须在派生类中实现
    - 含有纯虚拟函数的类称为抽象类，不能定义对象
4）构造函数和析构函数是否可以是虚函数：
    - 构造函数不能是虚函数，因为虚函数是基于对象，而构造函数用于定义对象
    - 析构函数可以是虚函数，因为当基类指针指向派生类对象时，若基类析构函数不是虚函数，则只析构了基类，造成派生类对象没有释放的问题（内存泄漏）
5）动态分配堆上内存时，析构函数必须是虚函数，以防止内存泄漏
6）部分函数不可以是虚函数：
    - 构造函数：无法继承且构造时未实例化，无法通过虚函数表指针寻找虚函数
    - 内联成员函数：内联函数在编译时展开，而虚函数则是运行时多态
    - 静态成员函数：静态函数被类成员共享，无法继承
    - 友元函数：不属于成员函数、无法继承
    - 普通函数：编译时已绑定，无法继承

5. 多态
1）派生类指针可以赋给基类指针，通过基类指针调用基类和派生类中的同名虚函数时：
    - 指向基类则调用基类虚函数
    - 指向派生类则调用派生类虚函数
2）派生类对象可以赋给基类引用，通过基类引用调用基类和派生类中的同名虚函数时：
    - 引用的是基类对象则调用基类虚函数
    - 引用的是派生类对象则调用派生类虚函数
3）多态是运行时概念，所以在构造函数和析构函数中调用虚函数不是多态（编译时即可确定）

6. 指针
1）普通指针（指向一个对象的地址）：
    - int* p = &num，p指向变量num
    - int* p_arr0 = arr，p_arr0指向arr数组第一个元素arr[0]
    - 不需要&取地址：数组（数组第一个元素的地址），函数（函数名的地址），字符串字面值常量右值（字符串在内存中的地址）
2）指向紧邻对象所占空间的下一个位置，常与迭代器使用的指针
3）智能指针（管理在堆上分配的内存）：
    - 将普通的指针封装为一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏
    - auto_ptr：C++11已弃用（以下C++11支持），存在潜在的内存崩溃问题（p2 = p1时，p2剥夺了p1的所有权，导致程序访问p1报错）
    - unique_ptr：独占式，同一时间内只有一个智能指针可以指向某对象（p2 = p1时报错；p2 = unique_ptr临时右值时成功，临时对象所有权让给p2后被销毁）
    - shared_ptr：共享式，多个智能指针可以指向同一对象，用计数机制来表明资源被几个指针共享，该对象和资源会在最后一个引用被销毁时释放
        - 存在内存泄漏：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效
        - use_count：返回引用计数的个数
        - unique：返回所有权是否为独占（use_count为1）
        - swap：交换两个shared_ptr对象（交换所拥有对象）
        - reset：放弃内部对象所有权或变更拥有对象, 会导致原有对象的引用计数减少
        - release：当前指针会释放资源所有权，计数减一
    - weak_ptr：搭配shared_ptr使用（无实际用处），不影响所指堆内存空间的引用计数，为解决shared_ptr相互引用时的死锁问题
4）空指针：指针变量赋值为NULL（C为 ((void*)0) ；C++为0）或nullptr
5）void*指针：无类型，不能对void*类型的指针做解指针操作，必须要进行正确的类型转换
6）常量指针：const int* ptr，指针的值为常量（即指向地址（*ptr）为常量），可以修改指向对象和指向对象的值
7）悬空指针：指向一块被已经被释放的内存
8）野指针：不确定其具体指向，最常来自于未初始化

7. 引用
1）引用&是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价
2）&不是求地址运算符，而是类似*的标志作用
3）引用的类型必须和其所绑定的变量的类型相同
4）声明引用的同时必须初始化
5）不能将已有的引用名作为其他变量或对象的名字或别名，即不可修改
6）引用不会开辟新的内存
7）引用的应用：
    - 函数参数（int &x）：与指针效果类似，此时函数中对形参的操作实际上是对实参本身进行操作，而不是将实参变量或对象的值拷贝给形参（节省内存空间）
    - 常引用：不允许通过该引用对其所绑定的变量或对象进行修改
    - 函数的返回值（int &fun(){}）：在内存中不产生返回值的副本
    - 实现多态（Son son;Father &ptr = son）：基类的引用用来绑定其派生类，只能用来访问派生类对象中从基类继承下来的成员（通过虚函数实现多态）

8. 内联函数
1）内联函数在调用时是编译器使用相应的函数代码替换函数调用，所以无需来回跳转
2）牺牲空间换时间，所以内联函数不能太复杂（代码简短，不能有for，while，switch等）
3）内联函数应该在头文件中定义，且在函数调用前定义

9. 静态
1）静态局部变量：生命周期为整个源程序，静态局部变量在函数退出后仍然存在但不可用，下次调用函数时才可使用，且保留变动后的值
2）静态全局变量：非静态全局变量的作用域是整个源程序，而静态全局变量的作用域则被限制为本源文件有效
3）静态函数：静态函数的作用域被限制为本源文件有效
4）类静态成员变量：编译时创建并初始化（类外），属于此类但不属于任何对象，被所有此类对象共享
5）类静态成员函数：属于此类但不属于任何对象，被所有此类对象共享，一般用于访问该类中的静态数据成员或全局变量
6）基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值

10. STL
1）容器（Container）：
    - vector：向量，尾端处理高效，添加元素时动态分配（内存连续，不足时：分配新空间 - 复制元素 - 释放原空间），删除元素时不释放空间
    - deque：双端队列，首尾端处理高效，具有分段数组（存储数据），索引数组（每段存储数据的首地址）
    - list：双向链表，链式存储，不支持随机访问
    - set/multiset：集合（红黑树，有序），存储一组无重复的元素（multiset可重复），修改某一个元素值时必须先删除元素再插入
    - map/multimap：映射（红黑树，有序），存储一组无重复键值的元素对（multimap可重复）
2）迭代器（Iterator）：
3）算法（Algorithm）：
4）仿函数（Functor）：
5）适配器（Adaptor）：
    - stack：栈，后进先出，默认顺序容器deque（封闭deque一端）
    - queue：队列，先进先出，默认顺序容器deque（限制在deque末尾添加元素，头部移除元素）
    - priority_queue：优先队列，优先级最高的元素排在队列头，默认顺序容器vector（限制在vector末尾添加元素，头部移除元素，且push_heap算法将元素最大/小元素排在队列头）
6）分配器（Allocator）：


11. 设计模式
1）单例模式：
    - 保证一个类只有一个实例，提供全局访问点来访问
    - 应用：日志，线程池
    - 实现：构造函数，拷贝构造/赋值符声明为private（阻止构造和拷贝），定义static函数接口（提供全局访问点，返回在类内部唯一构造的实例）
2）工厂模式：
    - 封装对象的创建，分离对象的创建和操作过程，用于批量管理对象的创建过程，便于程序的维护和扩展
    - 简单工厂模式：
        - 对于不同产品的创建定义一个工厂类，将产品的类型作为参数传入到工厂的创建函数，根据类型分支选择不同的产品构造函数
    - 工厂方法模式：
        - 不同的产品创建采用不同的工厂创建（从工厂的抽象基类派生），这样创建不同的产品过程就由不同的工厂分工解决
    - 抽象工厂模式：
        - 当具有多个抽象产品类型时，创建一系列相关或相互依赖的对象接口，而无需指定它们的具体类
3）策略模式：
    - 定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换，让算法独立于使用它的客户而独立变化
    - 角色：
        - 抽象策略角色（Strategy）：抽象策略类
        - 具体策略角色（ConcreteStrategy）：封装了相关的算法和行为
        - 环境角色（Context）：持有一个策略类的引用，最终给客户端调用
4）命令模式：
    - 命令模式将”请求“封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，也支持可撤销的操作


网络：
------------------------------------------------------------------------------------------------------------------------
1. OSI模型
由高到低：
1）应用层：为特定类型的网络应用提供访问OSI环境的手段，如HTTP，DHCP等
    - TCP协议服务及端口号：
        - HTTP（超文本传输协议）：80，传输Internet浏览器普通文本、超文本、音视频等数据
        - HTTPS（安全文本传输协议）：443，基于HTTP，应用了安全套接字层（SSL），可对数据进行加密和压缩
        - FTP（文件传输协议）：21（控制数据传输）/20（数据传输），用于文件传输，能进行目录操作和文件权限操作
        - SSH（安全外壳协议）：22
        - Telnet（远程登录）：23
        - SMTP（简单邮件传输协议）：25，负责服务器之间的邮件传送
        - POP3（邮局协议版本3）：110，用于支持客户端远程管理在服务器上的电子邮件
        - IMAP（交互式邮件存取协议）：143，类似POP3，但客户端收取的邮件会保留在服务器上，同时客户端上的操作会反馈到服务器上
    - UDP协议服务及端口号：
        - DNS（域名服务器）：53，用于域名解析
        - TFTP（简单文件传输协议）：69，类似TCP上的FTP，仅进行文件上传和下载
2）表示层：对数据进行翻译、加密、压缩等操作
3）会话层：确定会话的连接和中断
4）传输层：负责向两个主机中进程之间的通信提供端到端接口
    - 传输控制协议（TCP）：面向连接，面向字节流，可靠，全双工
        - TCP报文（封装在网络层的IP数据报中）：
            - 报头：源端口（16位），目的端口（16）；
                   序列号（32，SYN标识位1时为初始序列号）；
                   确认序列号（32，如果ACK标识位1则为准备接收的报文序列号）；
                   数据偏移（4，数据从何处开始），保留（6），标识位（6：URG、ACK、PSH、RST、SYN、FIN），窗口大小（16）；
                   校验和（16），紧急指针（16，URG标识位1时生效）；
                   选项（1 - ？，长度不定，没有选项即1字节的域等于0）
            - 数据：TCP报文负载的数据
        - 三次握手：
            - A -> B：客户端A向服务器B发出建立连接请求，SYN=j（j为序列号，SYN标识位为1）
            - A <- B：服务器B收到并确认客户端A，SYN=k，ACK=j+1（ACK为确认，确认号为收到的序列号+1）
            - A -> B：客户端A收到并确认服务端B，ACK=k+1
        - 四次挥手：
            - A -> B：客户端A数据发送完，向服务器B发出释放连接请求，FIN=m（m为序列号，FIN标识位为1）
            - A <- B：服务器B收到并确认客户端A，等待数据传输完成，ACK=m+1（ACK为确认，确认号为收到的序列号+1）
            - A <- B：数据传输完成，向客户端A发出释放连接请求，FIN=n，ACK=m+1
            - A -> B：客户端A收到并确认服务端B，ACK=n+1
    - 用户数据报协议（UDP）：无连接，面向报文，不可靠
        - UDP报文（封装在网络层的IP数据报中）：
            - 报头：源端口（16位），目的端口（16）；
                   长度（16，UDP报文长度，最小为8，只有报头），校验和（16）
            - 数据：UDP报文负载的数据
5）网络层：处理不同网络之间的数据路由和发送，包括路由选择、分段组合、流量/拥塞控制等
    - 网际协议地址（IP地址，IPv4/IPv6）：为互联网每个网络/主机分配一个逻辑地址（网络拓扑分配）
        - IP数据报（封装在数据链路层的帧的数据中）：
            - 报头：IP协议版本（4位），报头长度（4），服务类型（8：优先权3 短延时位1 高吞吐位1 高可靠位1 保留2），总长度（16）；
                   标识（16，MTU导致分片后正确重组），标志（3，无效-能否分片-后面还有分片），片偏移（13，片在分组相对位置）；
                   生存时间（8，限制路由跳数），上层协议标识（8，TCP/UDP等），校验和（16，通过报头校验有效性）；
                   源IP地址（32）；
                   目的IP地址（32）；
                   选项（1 - 40，支持排错、测量以及安全等，IPv6固定）
            - 数据：不同MTU（最大传输单元）存在分片问题，将数据分成连续片
        - IPv4分类（IPv4 32位， 分网络地址 + 主机地址）：
            - A类：1-127.x.x.x（0x），单播地址，网络地址8，主机地址24
            - B类：128-191.x.x.x（10x），单播地址，网络地址16，主机地址16
            - C类：192-223.x.x.x（110x），单播地址，网络地址24，主机地址8
            - D类：224-239.x.x.x（1110x），多播地址
            - E类：240-255.x.x.x（11110x），保留
            - 特殊地址：全0/全1，127.0.0.1（代表本地IP地址）-127.255.255.255用于回路测试
            - 默认子网掩码：网络地址为1，主机地址为0
            - 子网划分（从主机地址划子网）：把每类IP网络划分成子网，如255.255.255.192/26代表子网掩码有26个1，其子网数有(主机地址位-(32-26))^2
            - 超网划分（从网络地址划超网）：把若干小网络组合成超网
            - 公网连Internet，私网连局域网
    - 地址解析协议（ARP）：实现IP地址到MAC地址的转换
        - 发送ARP包，通过FF:FF:FF:FF:FF:FF + IP广播，获取目的MAC地址
        - ARP攻击：主要存在局域网中，通过发送ARP欺骗包（伪造IP及MAC地址），进行嗅探（截取数据再转发），网关欺骗（无法上网），IP地址冲突
    - Internet控制报文协议（ICMP）：用于在IP主机、路由器之间传递控制消息
        - ICMP报文包含在IP数据报的数据中
        - 消息类型：
            - 响应请求：发送响应请求报文（type=8），没有异常则返回应答请求报文（type=0），如ping
            - 目标不可到达，源抑制和超时报文：发送不可达报文（type=3， code=？），告知具体的不可达信息（code决定）
            - 时间戳：发送时间戳请求报文（type=13），收到返回的时间戳应答报文（type=14），计算来回一次的传输时间
        - ICMP攻击：通过发送ICMP报文，进行ICMP超限尺寸攻击（部分操作系统设限导致内存分配错误），ICMP报文轰炸（长时间，大量，连续）
    - Internet组管理协议（IGMP）：用于在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系
        - 组播：IP主机发给组播路由器（1份），组播路由器发给需要的组播组成员（多份）
        - IGMPv1：管理组播组成员基于查询（由组播路由协议如PIM决定IGMP查询器）和响应（超时响应来确定组播组成员离开）机制
        - IGMPv2：增加了查询器选举机制（IP地址最小成为查询器）和离开组（通知）机制
        - IGMPv3：增强了主机控制，查询和报告报文
    - 路由选择协议：
        - RIP协议：基于距离矢量的动态路由选择协议
        - OSPF协议：开放式最短路径优先
6）数据链路层：对电信号进行分组，即以太网协议Ethernet（标准），用于处理同一网络中不同设备之间的通信
    - 帧：一组电信号，分成报头head和数据data
        - 报头（固定18字节）：发送者/源MAC地址（6字节），接收者/目的MAC地址（6字节），数据类型（6字节）
        - 数据（46 - 1500字节）：数据包具体内容，超过最大限制分片
    - MAC地址（12位16进制）：Ethernet规定接入网络的设备都必要网卡，源/目的地址便是网卡的地址，即MAC地址（制造商分配）
    - 数据链路层工作方式：局域网广播
7）物理层：物理/硬件，中间物理链接如光缆、电缆、双绞线、无线电波；中间电信号，即010101...二进制
8）应用层，表示层，会话层 -> 应用层；数据链路层，物理层 -> 网络接口层

2. sshd_config部分详解
1）MaxSessions：控制单个TCP连接上支持的多路复用会话的数量
    - MaxSessions=0：禁止登录/shell/子系统会话
    - MaxSessions=1：禁用多路复用
    - MaxSessions=2+：允许多路复用

3. iptables
1）iptables位于用户空间，是一个命令行工具，其本质是Netfilter（Linux操作系统核心层内部的数据包处理模块）
2）iptables链：
    - INPUT：输入，到本机某进程的报文
    - OUTPUT：输出，由本机的某进程发出的报文（如响应报文）
    - PREROUTING：路由前，接收到报文，判断目的是否为本机，是则INPUT，否则FORWARD
    - FORWARD：转发
    - POSTROUTING：路由后，发送报文
3）iptables表：
    - filter表（内核模块：iptables_filter）：过滤，适用于INPUT，FORWARD，OUTPUT
    - nat表（iptable_nat）：网络地址转换功能，适用于路由/转发
    - mangle表（iptable_mangle）：拆解报文并修改，再重新封装，可用于ALL
    - raw表（iptable_raw）：关闭nat表上启用的连接追踪机制，适用于PREROUTING，OUTPUT
    - 规则优先级：raw -> mangle -> nat -> filter
4）匹配条件：
    - 基本匹配条件：源地址Source IP，目标地址Destination IP
    - 扩展匹配条件：源端口Source Port, 目标端口Destination Port
5）处理动作：
    - ACCEPT：允许数据包通过
    - DROP：直接丢弃数据包，不给任何回应信息，发送端超时才知
    - REJECT：拒绝数据包通过，必要时会给发送端发送响应
    - SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题
    - MASQUERADE：是SNAT的一种特殊形式，适用于动态的IP
    - DNAT：目标地址转换。、
    - REDIRECT：在本机做端口映射
    - LOG：/var/log/messages文件中记录日志信息，不做处理
6）iptables使用举例：iptables -t filter -I INPUT -s x.x.x.x -j DROP
    - t：指定要操作的表，不使用-t默认操作filter表
    - I：插入，即在添加规则（默认链首（可跟编号指定插入位置），-A则是在链尾添加，-D删除指定编号，-F清空）
    - s：匹配条件中的源地址
    - j：匹配条件满足时执行的处理工作
    - 解释：将规则[将来自x.x.x.x的报文都丢弃]插入filter表中

安全：
------------------------------------------------------------------------------------------------------------------------




多媒体：
------------------------------------------------------------------------------------------------------------------------
1. 媒体
1）原始数据（音频/视频） -> 压缩编码（pcm，mpeg/mpeg，h264） -> 封装/复用容器 -> 本地/流 -> 媒体源
2）媒体源 -> 解封装/解复用 -> 音频/视频流（缓存区，匹配解复用和解码间的速度） -> 解码 -> 音视频同步输出（播放/显示）

2. Gstreamer
1）Gstreamer支持Windows/Linux/Android等的跨平台多媒体框架
2）应用程序通过管道（Pipeline）的方式，将多媒体处理的各个步骤串联起来，每个步骤通过元素（Element）基于GObject对象系统通过插件（plugins）的方式实现
3）基础概念：
    - Element：元素对象类型，实现一个功能（读取文件，解码，输出等），多个Element串联实现一个Pipeline
    - Pad：Element的输入/输出接口，分为src pad（生产数据）和sink pad（消费数据），将两个Element连接（前src pad -> 后sink pad）起来处理
    - Bin：容器，用于管理多个Element，当Bin状态改变时，会自动去修改所管理的Element的状态，也会转发所收到的消息
    - Pipeline：继承自Bin，提供一个bus用于传输消息，并且对所有子Element进行同步（Pipeline的状态设置为PLAYING时，通过一个/多个新的线程中通过element处理数据）
4）Gstreamer结构：
    - Core Framework（核心框架）：
        - 上层应用接口
        - Piugin框架
        - Pipline框架
        - 数据在Element间的传输及处理机制
        - 媒体流（Streaming）间的同步（音视频同步等）
    - Plugins：
        - Protocols：负责协议的处理，file，http，rtsp等
        - Sources：负责数据源的处理，alsa，v4l2，tcp/udp等
        - Formats：负责媒体容器的处理，wav，mp4，ogg等
        - Codecs：负责媒体的编解码，mp3，vorbis等
        - Filters：负责媒体流的处理，converters，mixers，effects等
        - Sinks：负责媒体流输出到指定设备或目的地，alsa，xvideo，tcp/udp等
    - 工具：
        - gst-inspect-1.0：查看Gstreamer的Plugin、Element的信息
        - gst-launch-1.0：用于创建及执行一个Pipline，常用来验证相关功能
        - gst-discoverer-1.0：显示文件元数据和流信息
5）Gstreamer相关包：
    - gstreamer: 核心包，核心框架（Framework）和元素（Element）
    - gst-plugins-base: gstreamer所需的基础插件
    - gst-plugins-good: LGPL开源许可的高质量插件
    - gst-plugins-ugly: GPL等其他严格开源许可的高质量插件，如GPL开源许可的x264，x265
    - gst-plugins-bad: 尚未成熟的插件
6）使用举例（gst-launch-1.0播放音频过程会涉及的函数）：
    - GstElement *pipeline = gst_pipeline_new("管道名")：创建管道
    - GstElement *source = gst_element_factory_make("filesrc" , "元件名")：创建真实元件（filesrc/fakesrc两种源元件，make函数实际由find和create函数组合）
    - g_object_set(G_OBJECT(source), "location", file_file, NULL)：设置源元件source的location参数
    - GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline))：得到管道pipeline的消息总线
    - gst_bus_add_watch(bus, call_func, loop)：消息监控，call_func消息处理函数，loop为GMainLoop *
    - gst_bin_add_many(GST_BIN(pipeline), source, decoder, sink, NULL)：将多个组件（source，decoder，sink）添加到管道中
    - gst_element_link_many(source, decoder, sink, NULL)：将多个组件依次连接
    - gst_element_set_state(pipeline, GST_STATE_PLAYING)：设置管道状态，即开始播放（对播放音频而言，NULL空，READY准备，PAUSED暂停，PLAYING播放，但实际是组件的数据在处理）
    - gst_element_unref(source)：释放Element元素

3. FFmpeg
1）Fast Forward Moving Picture Experts Group
2）FFMPEG关键结构体
    - 解协议（http，rtmp等）：AVIOContext（管理输入输出数据，带缓冲），URLContext（协议对象及协议操作对象），URLProtocol（协议操作对象，对应一种协议对象）
    - 解封装/复用（flv，mp4等）：AVFormatContext（存储音视频封装格式中包含的信息，较多的码流参数），AVInputFormat（输入音视频使用的封装格式，对应一种容器）
    - 解码（h264，mpeg2）：AVStream（存储音视频流的相关数据，对应一个AVCodecContext），AVCodecContext（存储音视频流解码方式的相关数据，对应一个AVCodec），AVCodec（包含该音视频对应的解码器）
    - 存数据（视频1帧/结构，音频多帧/结构）：AVPacket（解码前数据，包），AVFrame（解码后数据，帧）
    - 关键结构体之间的关联（解码为例）：
        - AVFormatContext -> AVIOContext -> URLContext -> URLProtocol  - 协议层面
                          -> AVInputFormat  - 解封装/复用层面
                          -> AVStream（0/1,音频或视频） -> AVCodecContext -> AVCodec  - 解码层面
3）重要模块/库：
    - AVUtil：核心工具库，基本的音视频处理操作
    - AVFormat：文件格式和协议库，常用于读写文件及信息
    - AVCodec：编解码库
    - AVFilter：滤镜库，提供了包括音视频特效的处理
4）工具：
    - ffmpeg：用于媒体文件转换，如转码，可选编码器、视频时长、帧率、采样格式等
    - ffplay：用于播放媒体文件
    - ffprobe：用于查看媒体文件头信息
5）使用举例（读取音视频文件时长会涉及的函数）：
    - AVFormatContext *formatCtx = NULL：声明定义一个空的AVFormatContext结构体
    - av_register_all()：注册所有的编解码器、复用/解复用组件
    - avformat_network_init()：初始化网络，以支持流媒体
    - avformat_open_input(&formatCtx, url, NULL, NULL)：打开多媒体数据并且获取一些信息，将之存在formatCtx中
    - formatCtx->duration/1000000：formatCtx，即AVFormatContext结构体包含了时长信息，为duration，单位为毫秒
    - avformat_close_input(&formatCtx)：释放动作






其他：
------------------------------------------------------------------------------------------------------------------------
1. 内存布局
1）低地址 -> 高地址：代码区 -> 数据区 -> 堆区 -> 栈区
2）分区/段：
    - 代码区：.text，也称文本段，存放着编译后形成的CPU指令
    - 数据区：存放三类数据
        - 只读数据段：const及文字等常量
        - 已初始化的读写数据段：.data，已初始化的全局/静态变量
        - 未初始化的读写数据段：.bss，未初始化的全局/静态变量，程序执行前BSS段会自动清0
    - 堆区：大小可变，不连续（会使内存空间不连续，造成浪费），运行时由程序员动态分配，存放malloc, new等，通过链表分配
    - 栈区：大小可变（空间有限），连续，运行时由系统自动分配，存放函数参数，局部变量等，通过先进后出分配
3）任何程序数据都不会存储在地址为0的内存块中，被操作系统预留的内存块

2. 进程与线程
1）定义：
    - 进程：操作系统进行资源分配和调度的基本单位，是具有一定独立功能的程序在一个数据集上的一次动态执行过程
    - 线程：程序执行流的最小单元，是处理器调度和分派的基本单位，执行单一的顺序控制流程
2）一个进程由一个或多个线程组成，线程是进程中代码的不同执行线路
3）进程之间相互独立，线程共享某个进程的资源，对其他进程不可见

3. 进程间通信
1）管道（pipe），有名管道（named pipe）：管道用于父子进程间的通信，有名管道允许非父子进程间的通信
2）信号（signal）：信号是一种软件中断，向进程传递有关其他进程，操作系统和硬件状态的信息的方法，可以改变程序的流程
3）信号量（semaphore）：进程之间或同一进程的不同线程之间的同步互斥手段：
    - PV操作：P-1，<0则挂起执行线程；V+1，<=0则唤醒一个挂起的线程
    - PV操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区
    - PV操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环
    - 互斥信号量初值一般为1
4）消息队列（message queue）：消息队列是消息的链接表，具有写权限的进程按照一定规则向消息队列中添加新信息；具有读权限的进程则可以从消息队列中读取信息
5）共享内存（shared memory）：多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新（需要依靠同步操作，如互斥锁和信号量等）
6）套接字（socket）：用于网络中不同机器之间的进程间通信

4. 数据类型
1）字节数（32/64）：
    - char：1
    - short：2
    - int：4
    - long：4/8
    - long long：8
    - float：4
    - double：8
    - char *（指针变量）：4/8
2）类型强制转换：
    - 隐式强制转换：TYPE b = a；
    - 显式强制转换（包括以下C++函数）：TYPE b = (TYPE) a；
    - static_cast：用于基本类型的强制转换
    - const_cast：用于转换去除const属性
    - reinterpret_cast：用于不同类型之间的指针之间的转换，如不同类型之间函数指针的转换
    - dynamic_cast：用于多态类型之间的类型转换

5. 左值与右值
左值：lvalue（locator value），代表在内存中占有确定位置的对象（即有地址）
右值：rvalue，不在内存中占有确定位置的表达式

6. 深拷贝与浅拷贝
浅拷贝：通过拷贝他们所共享数据的指针来工作
深拷贝：通过拷贝数据来工作，互不影响

7. 计算机二进制
1）1字符 = 2字节
2）1字节 = 8位 = 8bit（比特）
3）汉字/中文标点符号 = 1字符；字母/数字/英文标点符号 = 1字节

8. 操作系统启动流程
1）加载BIOS（包含硬件CPU，内存，磁盘等）
2）读取MBR主引导记录（将Boot Loader复制到0x7c00地址所在物理空间，进行引导）
3）GRUB引导（引导启动操作系统）
4）加载Kernel内核（调取内存映像进行内核解压缩，再调用start_kernel()函数来初始化各种设备）
5）init进程启动（Linux操作系统第一个守护进程init，读取/etc/inittab设定的运行等级）
6）加载rc.sysinit（Linux操作系统第一个执行的用户层文件/etc/rc.d/rc.sysinit，设定PATH、/proc、网络配置、启动swap分区等）
7）加载内核模块
8）启动rc0.d-rc6.d（初始化工作和启动相应的服务）
9）启动自定义服务（/etc/rc.d/rc.local，系统开机时会读取）
10）执行/bin/login（登录）