C/C++基础：
------------------------------------------------------------------------------------------------------------------------
1. const关键字作用
1）防止被修饰变量的内容改变，需要先初始化（类成员变量只能在初始化列表中赋值）
2）const可以修饰指针：
    - 常量指针/常指针（const int* ptr），指针的值为常量，不能修改其指向地址（*ptr），但可以修改指向对象和指向对象的值
    - 指针常量，（int* const ptr），指针为常量，不能修改指向对象(ptr)，但可以修改指向地址和指向对象的值
    - 指向常量的常指针（const int* const ptr），同上，只能修改指向对象的值
3）const可以修饰函数：
    - 修饰形参表的输入参数，在函数内部不能修改其值
    - 修饰函数返回值，和修饰变量等同
    - 修饰类的成员函数，指定其为常函数，不能修改成员变量，不能调用非const成员函数
    - 修饰类的成员函数，指定其返回值为const，使其不为左值
    - 修饰类的成员函数，const不能与static同时使用，因为静态成员函数不含有this指针（不能实例化），但const成员函数必须实例化（this指向内容不可变）
4）const可以修饰类对象，对象的任何成员都不能被修改，只能调用const成员函数
5）const可以替代#define宏定义：
    - 宏定义编译时，不能进行调试，生命周期结束于编译时；const运行时
    - 宏定义不会分配内存，存储在代码段；const会分配内存
    - 宏定义无数据类型区别；const有数据类型区别，会进行类型安全检查
    - 宏定义函数内定义全局生效；const函数内定义本函数内生效

2. class与struct区别
1）class成员默认为private属性的；struct成员默认为public属性的
2）class继承默认是private继承；struct继承默认是public继承
3）class可以使用模板，而struct不能
4）C++中struct类似于class，可以包含成员函数；C中struct不能包含函数

3. 函数重载，函数覆盖，函数隐藏的区别
1）函数重载：类中一组具有相同函数名，但参数列表不同的函数，根据函数调用时传入的实参类型，匹配对应的函数并调用
2）函数覆盖/函数重写：类父子中具有相同的函数原型（函数名、参数列表），父类定义为虚函数，子类重新实现该函数
3）函数隐藏：类父子中具有相同的函数原型（函数名、参数列表），父类定义为非虚函数，则在子类中隐藏父类的同名函数

4. 虚函数
1）虚函数的实现：
    - 虚函数指针，指向对应的虚函数，总是被存放在该对象的地址首位（提高性能），对外部不可见
    - 虚函数表，虚函数指针按照一定顺序构成的表状结构，一个类公用一张虚函数表
2）虚函数是实现多态的机制
3）纯虚函数：基类虚函数原型后加［ = 0 ］，提供该函数的规范接口：
    - 纯虚函数在基类没有定义
    - 纯虚函数必须在派生类中实现
    - 含有纯虚拟函数的类称为抽象类，不能定义对象
4）构造函数和析构函数是否可以是虚函数：
    - 构造函数不能是虚函数，因为虚函数是基于对象，而构造函数用于定义对象
    - 析构函数可以是虚函数，因为当基类指针指向派生类对象时，若基类析构函数不是虚函数，则只析构了基类，造成派生类对象没有释放的问题（内存泄漏）
5）动态分配堆上内存时，析构函数必须是虚函数，以防止内存泄漏
6）部分函数不可以是虚函数：
    - 构造函数：无法继承且构造时未实例化，无法通过虚函数表指针寻找虚函数
    - 内联成员函数：内联函数在编译时展开，而虚函数则是运行时多态
    - 静态成员函数：静态函数被类成员共享，无法继承
    - 友元函数：不属于成员函数、无法继承
    - 普通函数：编译时已绑定，无法继承

5. 多态
1）派生类指针可以赋给基类指针，通过基类指针调用基类和派生类中的同名虚函数时：
    - 指向基类则调用基类虚函数
    - 指向派生类则调用派生类虚函数
2）派生类对象可以赋给基类引用，通过基类引用调用基类和派生类中的同名虚函数时：
    - 引用的是基类对象则调用基类虚函数
    - 引用的是派生类对象则调用派生类虚函数
3）多态是运行时概念，所以在构造函数和析构函数中调用虚函数不是多态（编译时即可确定）

6. 指针
1）普通指针（指向一个对象的地址）：
    - int* p = &num，p指向变量num
    - int* p_arr0 = arr，p_arr0指向arr数组第一个元素arr[0]
    - 不需要&取地址：数组（数组第一个元素的地址），函数（函数名的地址），字符串字面值常量右值（字符串在内存中的地址）
2）指向紧邻对象所占空间的下一个位置，常与迭代器使用的指针
3）智能指针（管理在堆上分配的内存）：
    - 将普通的指针封装为一个栈对象，当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏
    - auto_ptr：C++11已弃用（以下C++11支持），存在潜在的内存崩溃问题（p2 = p1时，p2剥夺了p1的所有权，导致程序访问p1报错）
    - unique_ptr：独占式，同一时间内只有一个智能指针可以指向某对象（p2 = p1时报错；p2 = unique_ptr临时右值时成功，临时对象所有权让给p2后被销毁）
    - shared_ptr：共享式，多个智能指针可以指向同一对象，用计数机制来表明资源被几个指针共享，该对象和资源会在最后一个引用被销毁时释放
        - 存在内存泄漏：当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效
        - use_count：返回引用计数的个数
        - unique：返回所有权是否为独占（use_count为1）
        - swap：交换两个shared_ptr对象（交换所拥有对象）
        - reset：放弃内部对象所有权或变更拥有对象, 会导致原有对象的引用计数减少
        - release：当前指针会释放资源所有权，计数减一
    - weak_ptr：搭配shared_ptr使用（无实际用处），不影响所指堆内存空间的引用计数，为解决shared_ptr相互引用时的死锁问题
4）空指针：指针变量赋值为NULL（C为 ((void*)0) ；C++为0）或nullptr
5）void*指针：无类型，不能对void*类型的指针做解指针操作，必须要进行正确的类型转换
6）常量指针：const int* ptr，指针的值为常量（即指向地址（*ptr）为常量），可以修改指向对象和指向对象的值
7）悬空指针：指向一块被已经被释放的内存
8）野指针：不确定其具体指向，最常来自于未初始化

7. 引用
1）引用&是某一个变量或对象的别名，对引用的操作与对其所绑定的变量或对象的操作完全等价
2）&不是求地址运算符，而是类似*的标志作用
3）引用的类型必须和其所绑定的变量的类型相同
4）声明引用的同时必须初始化
5）不能将已有的引用名作为其他变量或对象的名字或别名，即不可修改
6）引用不会开辟新的内存
7）引用的应用：
    - 函数参数（int &x）：与指针效果类似，此时函数中对形参的操作实际上是对实参本身进行操作，而不是将实参变量或对象的值拷贝给形参（节省内存空间）
    - 常引用：不允许通过该引用对其所绑定的变量或对象进行修改
    - 函数的返回值（int &fun(){}）：在内存中不产生返回值的副本
    - 实现多态（Son son;Father &ptr = son）：基类的引用用来绑定其派生类，只能用来访问派生类对象中从基类继承下来的成员（通过虚函数实现多态）

8. 内联函数
1）内联函数在调用时是编译器使用相应的函数代码替换函数调用，所以无需来回跳转
2）牺牲空间换时间，所以内联函数不能太复杂（代码简短，不能有for，while，switch等）
3）内联函数应该在头文件中定义，且在函数调用前定义

9. 静态
1）静态局部变量：生命周期为整个源程序，静态局部变量在函数退出后仍然存在但不可用，下次调用函数时才可使用，且保留变动后的值
2）静态全局变量：非静态全局变量的作用域是整个源程序，而静态全局变量的作用域则被限制为本源文件有效
3）静态函数：静态函数的作用域被限制为本源文件有效
4）类静态成员变量：编译时创建并初始化（类外），属于此类但不属于任何对象，被所有此类对象共享
5）类静态成员函数：属于此类但不属于任何对象，被所有此类对象共享，一般用于访问该类中的静态数据成员或全局变量
6）基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值

10. STL
1）容器（Container）：
    - vector：向量，尾端处理高效，添加元素时动态分配（内存连续，不足时：分配新空间 - 复制元素 - 释放原空间），删除元素时不释放空间
    - deque：双端队列，首尾端处理高效，具有分段数组（存储数据），索引数组（每段存储数据的首地址）
    - list：双向链表，链式存储，不支持随机访问
    - set/multiset：集合（红黑树，有序），存储一组无重复的元素（multiset可重复），修改某一个元素值时必须先删除元素再插入
    - map/multimap：映射（红黑树，有序），存储一组无重复键值的元素对（multimap可重复）
2）迭代器（Iterator）：
3）算法（Algorithm）：
4）仿函数（Functor）：
5）适配器（Adaptor）：
    - stack：栈，后进先出，默认顺序容器deque（封闭deque一端）
    - queue：队列，先进先出，默认顺序容器deque（限制在deque末尾添加元素，头部移除元素）
    - priority_queue：优先队列，优先级最高的元素排在队列头，默认顺序容器vector（限制在vector末尾添加元素，头部移除元素，且push_heap算法将元素最大/小元素排在队列头）
6）分配器（Allocator）：


11. 设计模式
1）单例模式：
    - 保证一个类只有一个实例，提供全局访问点来访问
    - 应用：日志，线程池
    - 实现：构造函数，拷贝构造/赋值符声明为private（阻止构造和拷贝），定义static函数接口（提供全局访问点，返回在类内部唯一构造的实例）
2）工厂模式：
    - 封装对象的创建，分离对象的创建和操作过程，用于批量管理对象的创建过程，便于程序的维护和扩展
    - 简单工厂模式：
        - 对于不同产品的创建定义一个工厂类，将产品的类型作为参数传入到工厂的创建函数，根据类型分支选择不同的产品构造函数
    - 工厂方法模式：
        - 不同的产品创建采用不同的工厂创建（从工厂的抽象基类派生），这样创建不同的产品过程就由不同的工厂分工解决
    - 抽象工厂模式：
        - 当具有多个抽象产品类型时，创建一系列相关或相互依赖的对象接口，而无需指定它们的具体类
3）策略模式：
    - 定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换，让算法独立于使用它的客户而独立变化
    - 角色：
        - 抽象策略角色（Strategy）：抽象策略类
        - 具体策略角色（ConcreteStrategy）：封装了相关的算法和行为
        - 环境角色（Context）：持有一个策略类的引用，最终给客户端调用
4）命令模式：
    - 命令模式将”请求“封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，也支持可撤销的操作

12. 虚基类与虚继承
1）继承方式前加上virtual关键字就是虚继承，使派生类中只保留一份间接基类的成员，解决多继承时命名冲突和冗余数据的问题
2）虚继承让某个类做出声明，可共享其基类，该基类就是虚基类
3）虚继承不会影响派生类本身，但会影响派生类进一步派生的类
4）二义性：虚基类定义了x，两个派生类也定义x，该两派生类进一步派生的类则存在二义性问题（不知x来自于哪个派生类）

其他：
------------------------------------------------------------------------------------------------------------------------
1. 内存布局
1）低地址 -> 高地址：代码区 -> 数据区 -> 堆区 -> 栈区
2）分区/段：
    - 代码区：.text，也称文本段，存放着编译后形成的CPU指令
    - 数据区：存放三类数据
        - 只读数据段：const及文字等常量
        - 已初始化的读写数据段：.data，已初始化的全局/静态变量
        - 未初始化的读写数据段：.bss，未初始化的全局/静态变量，程序执行前BSS段会自动清0
    - 堆区：大小可变，不连续（会使内存空间不连续，造成浪费），运行时由程序员动态分配，存放malloc, new等，通过链表分配
    - 栈区：大小可变（空间有限），连续，运行时由系统自动分配，存放函数参数，局部变量等，通过先进后出分配
3）任何程序数据都不会存储在地址为0的内存块中，被操作系统预留的内存块

2. 进程与线程
1）定义：
    - 进程：操作系统进行资源分配和调度的基本单位，是具有一定独立功能的程序在一个数据集上的一次动态执行过程
    - 线程：程序执行流的最小单元，是处理器调度和分派的基本单位，执行单一的顺序控制流程
2）一个进程由一个或多个线程组成，线程是进程中代码的不同执行线路
3）进程之间相互独立，线程共享某个进程的资源，对其他进程不可见

3. 进程间通信
1）管道（pipe），有名管道（named pipe）：管道用于父子进程间的通信，有名管道允许非父子进程间的通信
2）信号（signal）：信号是一种软件中断，向进程传递有关其他进程，操作系统和硬件状态的信息的方法，可以改变程序的流程
3）信号量（semaphore）：进程之间或同一进程的不同线程之间的同步互斥手段：
    - PV操作：P-1，<0则挂起执行线程；V+1，<=0则唤醒一个挂起的线程
    - PV操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区
    - PV操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环
    - 互斥信号量初值一般为1
4）消息队列（message queue）：消息队列是消息的链接表，具有写权限的进程按照一定规则向消息队列中添加新信息；具有读权限的进程则可以从消息队列中读取信息
5）共享内存（shared memory）：多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新（需要依靠同步操作，如互斥锁和信号量等）
6）套接字（socket）：用于网络中不同机器之间的进程间通信

4. 数据类型
1）字节数（32/64）：
    - char：1
    - short：2
    - int：4
    - long：4/8
    - long long：8
    - float：4
    - double：8
    - char *（指针变量）：4/8
2）类型强制转换：
    - 隐式强制转换：TYPE b = a；
    - 显式强制转换（包括以下C++函数）：TYPE b = (TYPE) a；
    - static_cast：用于基本类型的强制转换
    - const_cast：用于转换去除const属性
    - reinterpret_cast：用于不同类型之间的指针之间的转换，如不同类型之间函数指针的转换
    - dynamic_cast：用于多态类型之间的类型转换

5. 左值与右值
左值：lvalue（locator value），代表在内存中占有确定位置的对象（即有地址）
右值：rvalue，不在内存中占有确定位置的表达式

6. 深拷贝与浅拷贝
浅拷贝：通过拷贝他们所共享数据的指针来工作
深拷贝：通过拷贝数据来工作，互不影响

7. 计算机二进制
1）1字符 = 2字节
2）1字节 = 8位 = 8bit（比特）
3）汉字/中文标点符号 = 1字符；字母/数字/英文标点符号 = 1字节

8. 操作系统启动流程
1）加载BIOS（包含硬件CPU，内存，磁盘等）
2）读取MBR主引导记录（将Boot Loader复制到0x7c00地址所在物理空间，进行引导）
3）GRUB引导（引导启动操作系统）
4）加载Kernel内核（调取内存映像进行内核解压缩，再调用start_kernel()函数来初始化各种设备）
5）init进程启动（Linux操作系统第一个守护进程init，读取/etc/inittab设定的运行等级）
6）加载rc.sysinit（Linux操作系统第一个执行的用户层文件/etc/rc.d/rc.sysinit，设定PATH、/proc、网络配置、启动swap分区等）
7）加载内核模块
8）启动rc0.d-rc6.d（初始化工作和启动相应的服务）
9）启动自定义服务（/etc/rc.d/rc.local，系统开机时会读取）
10）执行/bin/login（登录）

9. 排序算法
1）稳定（a在b前面且a，b相等，排序后a仍在b前面），（时间复杂度最好 -> 最坏，空间复杂度，举例皆从小到大排序）
    - 冒泡排序（n -> n^2， 1）：依次比较相邻元素，将较小元素交换在前面，重复n遍
    - 插入排序（n -> n^2， 1）：取出待排序元素，与前面已排序元素比较，已排序元素若较大则后移，依次比较，将待排序元素插入其相等或较大的位置，重复n遍
    - 归并排序（nlog2n， n）：将n长序列分成两个n/2长的子序列，对子序列再使用归并排序递归，将两个子序列合并成一个序列，直至最终排序
    - 计数排序（n+k， n+k）：找出最小/最大元素，统计该范围（要求确定范围的整数）i值元素出现次数并存入数组（额外开辟的数组空间）第i项，计数累加并反向填充数列
    - 桶排序（n -> n^2， n+k）：利用函数映射（类似计数排序，给范围内元素分桶）将元素放入一个定量数组（桶），对每个非空桶排序，再将各非空桶拼接起来
    - 基数排序（n*k，n+k）：以最大元素获取最大位数，从最低位开始计数排序，然后次低位计数排序...最后最高位计数排序
2）不稳定
    - 快速排序（nlog2n -> n^2， nlog2n）：从序列中挑选基准（以此划分子序列），将小于基准的元素放前面，大于基准的元素放后面，对子序列再使用快速排序递归
    - 选择排序（n^2，1）：遍历所有元素，选择最大/小元素排在前面，重复n遍（每一遍会确定一个最大/小元素）
    - 希尔排序（n -> n^2，1）：类似插入排序，又称缩小增量排序，将整个待排序的序列分割（核心是间隔序列）为子序列，分别进行直接插入排序
    - 堆排序（nlog2n， 1）：根据堆积（子结点的键值总是小于/大于父节点），先将元素构成堆（无序区），通过元素交换满足堆顶元素总是最大的，然后将堆顶元素和无序区最后的元素交换（形成有序区，交换新堆又无序，重复)

10. 二叉树
1）非线性结构，只有一个根节点，每个节点上最多左右两颗子树（二叉）
2）节点和树：
    - 节点：
        - 度：节点拥有的子树数量，0 ～ 2
        - 叶子节点（终端节点）：度为零（没有子树）的节点
        - 分支节点（非终端节点）：度不为零的节点
        - 双亲节点：即子树的父节点
    - 树：
        - 度：树中所有节点的度的最大值
        - 层：到根节点的层次数，根节点为第一层
        - 深度：最长纵向节点数，即最大层
3）二叉树：
    - 类型：
        - 满二叉树：最大层都是叶子节点，且分支节点的度都为2
        - 完全二叉树：去掉最大层为满二叉树，且最大层都是叶子节点，依次从左至右分布
    - 性质（最多即满二叉树）：
        - 第k层节点最多有2^(k-1)
        - 深度为l的树的总节点:最多2^l-1
        - n个节点的深度最大log2^n+1
        - 叶子节点 = 度为2的分支节点 + 1
        - 对完全二叉树顺序编号（1 < i < n）：
            - i = 1：根节点
            - i > 1：该节点的双亲节点编号为i/2
            - 2i ≤ n：有编号为2i的左节点，否则（即2i > n）无左节点
            - 2i+1 ≤ n：有编号为2i+1的右节点，否则无右节点
4）遍历：根节点决定前中后，只能从左子树到右子树
    - 前序遍历：根左右
    - 中序遍历：左根右
    - 后续遍历：左右根
