1. const关键字作用
1）防止被修饰变量的内容改变，需要先初始化（类成员变量只能在初始化列表中赋值）
2）const可以修饰指针：
    - 常量指针/常指针（const int* ptr），指针的值为常量，不能修改其指向地址（*ptr），但可以修改指向对象和指向对象的值
    - 指针常量，（int* const ptr），指针为常量，不能修改指向对象(ptr)，但可以修改指向地址和指向对象的值
    - 指向常量的常指针（const int* const ptr），同上，只能修改指向对象的值
3）const可以修饰函数：
    - 修饰形参表的输入参数，在函数内部不能修改其值
    - 修饰函数返回值，和修饰变量等同
    - 修饰类的成员函数，指定其为常函数，不能修改成员变量，不能调用非const成员函数
    - 修饰类的成员函数，指定其返回值为const，使其不为左值
    - 修饰类的成员函数，const不能与static同时使用，因为静态成员函数不含有this指针（不能实例化），但const成员函数必须实例化（this指向内容不可变）
4）const可以修饰类对象，对象的任何成员都不能被修改，只能调用const成员函数
5）const可以替代#define宏定义：
    - 宏定义编译时，不能进行调试，生命周期结束于编译时；const运行时
    - 宏定义不会分配内存，存储在代码段；const会分配内存
    - 宏定义无数据类型区别；const有数据类型区别，会进行类型安全检查
    - 宏定义函数内定义全局生效；const函数内定义本函数内生效

2. class与struct区别
1）class成员默认为private属性的；struct成员默认为public属性的
2）class继承默认是private继承；struct继承默认是public继承
3）class可以使用模板，而struct不能
4）C++中struct类似于class，可以包含成员函数；C中struct不能包含函数

3. 函数重载，函数覆盖，函数隐藏的区别
1）函数重载：类中一组具有相同函数名，但参数列表不同的函数，根据函数调用时传入的实参类型，匹配对应的函数并调用
2）函数覆盖/函数重写：类父子中具有相同的函数原型（函数名、参数列表），父类定义为虚函数，子类重新实现该函数
3）函数隐藏：类父子中具有相同的函数原型（函数名、参数列表），父类定义为非虚函数，则在子类中隐藏父类的同名函数

4. 虚函数
1）虚函数的实现：
    - 虚函数指针，指向对应的虚函数，总是被存放在该对象的地址首位（提高性能），对外部不可见
    - 虚函数表，虚函数指针按照一定顺序构成的表状结构，一个类公用一张虚函数表
2）虚函数是实现多态的机制
3）纯虚函数：基类虚函数原型后加［ = 0 ］，提供该函数的规范接口：
    - 纯虚函数在基类没有定义
    - 纯虚函数必须在派生类中实现
    - 含有纯虚拟函数的类称为抽象类，不能定义对象
4）构造函数和析构函数是否可以是虚函数：
    - 构造函数不能是虚函数，因为虚函数是基于对象，而构造函数用于定义对象
    - 析构函数可以是虚函数，因为当基类指针指向派生类对象时，若基类析构函数不是虚函数，则只析构了基类，造成派生类对象没有释放的问题（内存泄漏）
5）动态分配堆上内存时，析构函数必须是虚函数，以防止内存泄漏

5. 多态
1）派生类指针可以赋给基类指针，通过基类指针调用基类和派生类中的同名虚函数时：
    - 指向基类则调用基类虚函数
    - 指向派生类则调用派生类虚函数
2）派生类对象可以赋给基类引用，通过基类引用调用基类和派生类中的同名虚函数时：
    - 引用的是基类对象则调用基类虚函数
    - 引用的是派生类对象则调用派生类虚函数
3）多态是运行时概念，所以在构造函数和析构函数中调用虚函数不是多态（编译时即可确定）


