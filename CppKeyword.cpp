/*
 *～～～～～～～～～～～～～～～～～～～～～～～～ 数 据 类 型 ～～～～～～～～～～～～～～～～～～～～～～～～
 */
1. auto
根据变量的初始值自动推断类型（如for循环中变量默认声明为auto），用auto声明的变量必须初始化。

2. bool
逻辑型变量定义符，C++中可以和int混用，其值为true（真，非0）或false（假，0）。

3. true
真（等同于int的非0值），基本数据结构bool类型的值之一。

4. false
假（等同于int的0值），基本数据结构bool类型的值之一。

5. int
整数类型的基本数据结构，精度大于short，小于long。

6. short
短整数类型的基本数据结构，精度小于int。

7. long
长整数类型的基本数据结构，精度大于int。

8. float
浮点数类型的基本数据结构，精度小于double。

9. double
双精度类型的基本数据结构，以双精度形式存储一个浮点数。

10. char
字符类型的基本数据结构，一般为0~255的int，对应ASCII码。char类型的数据需要单引号’’。

11. wchar_t
宽字符类型的基本数据结构，每个wchar_t类型占2个字节，可用于汉字的表示。

12. enum
枚举，给出一系列固定的值（int），只能选择其中之一。

13. union
联合体，可以用于所有类型，并且其占用空间是随着实际类型大小变化的。

14. struct
结构体，与C语言兼容（class关键字是不与C语言兼容的），可以实现面向对象程序设计。

15. class
类，面向对象设计的基础。


/*
 *～～～～～～～～～～～～～～～～～～～～～～～～ 流 程 结 构 ～～～～～～～～～～～～～～～～～～～～～～～～
 */
1. if
条件语句，可以根据后面的bool类型的值选择进入一个分支执行。

2. else
条件语句，紧跟在if后面，用于对if不成立的情况的选择。

3. switch
多分支语句，类似于if-else-if语句。switch后面的判断只能是int（char型本质上也是int类型）。

4. case
多分支语句，用于switch语句中，当变量为某个值时执行对应case。

5. default
多分支语句，用于switch语句中，不满足所有的case时进入default执行。default可以没有，但只能放在case之后。

6. do
循环语句，do-while是一类循环结构，保证至少要进入一次循环体。

7. while
循环语句，满足某个条件后进入循环体，不满足则不进入。while也用于do-while循环结构中。

8. for
循环语句，用于有确定开始和结束。

9. continue
用于循环结构，使程序跳过代码段内后面的部分继续循环，区别直接跳出代码段的break。

10. break
在switch/循环语句中跳过该程序段，一个break只能跳出一层switch/循环。

11. goto
用于无条件跳转到某一标号处开始执行。

12. return
用于在函数中返回值，程序在执行到return语句后立即返回调用函数处，不再执行调用函数剩余内容。

13. throw
用于实现C++的异常处理机制，“抛出”一个异常。

14. try
用于实现C++的异常处理机制，在try中调用可能抛出异常的函数，然后在try后面的catch中捕获并进行处理。

15. catch
catch和try语句一起用于异常处理。


/*
 *～～～～～～～～～～～～～～～～～～～～～～～～ 修 饰 定 义 ～～～～～～～～～～～～～～～～～～～～～～～～
 */
1. const
修饰的对象或变量不能被改变，即常量。
const修饰函数时，该函数不能改变函数外声明的变量，也不能调用非const函数。
const修饰变量时，该变量就是一个带类型的常量，相当于多了类型信息的#define，且能执行内链接。
在C语言中，声明则必须放在源文件中，是一个不可改变的变量。

2. signed
表明该类型是有符号数，数字类型（整型和浮点型）都可以用signed修饰（默认）。

3. unsigned
表明该类型是无符号数。

4. register
声明的变量称着寄存器变量，直接存放在寄存器中；
但对32位编译器不起作用，当global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与register关键字有关的其它符号都对32位编译器有效。

5. inline
定义内联函数，将在编译时在调用处展开。inline函数一般由短小的语句组成，能提高程序效率。

6. export
访问其他编译单元（如另一代码文件）中的变量或对象，对模板类型，必须在定义这些模板类对象和模板函数时使用export。

7. extern
访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（基本数据类、结构和类），可以利用extern来使用这些变量或对象。
被其修饰的变量（外部变量）是静态分配空间的，声明后应有实现，在程序开始时分配，结束时释放。
在C++中，还可用来指定使用C语言进行链接，需要与”C”转换符一起使用，来支持C编译器链接。
例如：
	extern “C” 声明
	extern “C” { 声明 }

8. template
用法：template<typename T> void func(T& t1, T& t2);
模板，C++中泛型机制的实现。
例如：
	// 模板声明如用法所示
	int num1 = 1, num2 = 2;
	func<int>(num1, num2);

9. typename
告知编译器把一个特殊的名字解释成一个类型。
在下列情况下必须使用：
唯一的name（可以作为类型理解），嵌套在另一个类型中；
模板参数在某种程度上包含这个name；
当模板参数使编译器在指认一个类型时产生了误解。

10. typedef
用法：typedef 类型 定义名（该类型的新名字）
类型说明定义了一个数据类型的新名字，而非新的数据类型。

11. void
空的。
可以作为函数返回值，表明不返回任何数据；
可以作为参数，表明没有参数传入（C++中非必须）；
可以作为指针使用。

12. volatile
用法：int volatile nVint;
不稳定的，限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变。
该声明的值随时会改变，系统在需要时会经常读写这个对象的值，因此常用于异步进程进行内存单元访问。

13. static
静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为0，使用时可改变其值。
静态变量或静态函数，只有本文件内的代码才可访问它，在其它文件中不可见，也称为“文件作用域”。
在C++类的成员变量被声明为static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；
而类的静态成员函数也只能访问静态成员（变量或函数）。
类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private类型的也不例外。

14. private
私有的，被标明为private的字段只能在本类以及友元中访问。

15. protected
受保护的，被标明为protected的字段只能在本类以及其继承类和友元中访问。

16. public
公有的，被标明为public的字段可以在任何类中访问。

17. explicit
构造函数显式声明，防止单参数类构造函数的隐式自动转换。

18. friend
友元关系声明，友元可以直接访问与其有friend关系类中的private/protected成员，能提高效率。
友元包括友元函数和友元类。

19. mutable
用于类的非静态和非常量数据成员，如果类的某个成员函数被声明为const类型，但需要在该函数中对类的数据成员进行赋值，就需要mutable。

20. virtual
C++中用来实现多态机制，虚的。


/*
 *～～～～～～～～～～～～～～～～～～～～～～～～ 类 型 转 换 ～～～～～～～～～～～～～～～～～～～～～～～～
 */
1. dynamic_cast
动态转换，允许在运行时进行类型转换，使程序能在类层次结构安全地转换类型，将基类的指针或引用安全地转换成派生类的指针或引用。

2. const_cast
用法：const_cast<type_id>(expression)
用来修改类型的const或volatile属性， type_id和expression的类型是一样的。
常量指针被转化成非常量指针，并且仍然指向原来的对象；
常量引用被转换成非常量引用，并且仍然指向原来的对象；
常量对象被转换成非常量对象。
例如：
	const X *pX = new X(1);       // 类X，数据成员m_x， m_x = 1;
	//pX->m_x = 2;                 // pX指针指向常对象，其成员变量m_x只读，所以报错。
	X* pX2 = const_cast<X*>(pX);  // 去掉pX指针的const属性
	pX2->m_x = 3;                  // pX2指针指向一般对象，其成员变量m_x可读写。
	cout << pX->m_x << endl;       // 输出：3

3. reinterpret_cast
用法：reinpreter_cast<type-id>(expression)
type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。

4. static_cast
用法：static_cast < type-id > ( expression ) 
该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：
用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。
用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
把空指针转换成目标类型的空指针。
把任何类型的表达式转换成void类?
注意：static_cast不能转换掉expression的const、volitale、或者__unaligned属性。


/*
 *～～～～～～～～～～～～～～～～～～～～～～～～ 功 能 运 算 ～～～～～～～～～～～～～～～～～～～～～～～～
 */
1. new
用于新建一个对象，总是返回一个指针。

2. delete
释放程序动态申请的内存空间。delete一个指针或数组[]，并且只能delete通过new申请的指针，否则会发生段错误。

3. sizeof
用sizeof获得某种数据类型占用的字节数。

4. typeid
用法：typeid(表达式 or 数据类型)
指出指针或引用指向的对象的实际派生类型。

5. operator
用于操作符重载。


/*
 *～～～～～～～～～～～～～～～～～～～～～～～～ 其 他 ～～～～～～～～～～～～～～～～～～～～～～～～
 */
1. using
表明使用namespace。

2. namespace
命名空间，用于在逻辑上组织类，是一种比类大的结构。

3. asm
允许在C++程序中嵌入汇编代码。

4. this
返回调用者本身的指针。

